# Устная часть L1

### 1. Какой самый эффективный способ конкатенации строк?
Ответ: strings.Builder

### 2. Что такое интерфейсы, как они применяются в Go?
Ответ: Интерфесы 

### 3. Чем отличаются RWMutex от Mutex?
Ответ: RWMutex предоставляет дополнительные RLock() и RUnlock(), которые позволяют заблокировать/разблокировать данные на чтение. Это полезно когда в программе много читателей и все пара писателей.
RLock() блокирует данные на запись, при этом данные можно параллельно читать. А при Lock() блокируется так же и RLock()

### 4. Чем отличаются буферизированные и не буферизированные каналы?
Ответ: В каналах по умолчанию буфер равен нулю. Запись в такой канал блокируется, пока канал не будет прочтен. В буферизированом канале есть буфер, и писать в него можно пока буфер не заполнится. В таком случае запись в канал блокируется пока не освободиться место в буфере

### 5. Какой размер у структуры struct{}{}?
Ответ: размер пустой стурктуры равен 0
```go
fmt.Println(reflect.TypeOf(struct{}{}).Size()) // 0
```

### 6. Есть ли в Go перегрузка методов или операторов?
Ответ: По скольку Go разрабатывался по принципу "чтобы еще убрать из языка" перегрузки методов и операторов в нем нет
Однако в go можно переопределить методы встраиваемой структуры:
https://go.dev/play/p/IqISqSnGOvL
```go
type Human struct {
  Name string
}

func (h *Human) SayHello() {
  fmt.Println("Hello, world!")
}

type Programmer struct {
  Human
}

func (p *Programmer) SayHello(lang string) {
  fmt.Printf("[%s]: Hello, %s!\n", p.name, lang)
}

```

### 7. В какой последовательности будут выведены элементы map[int]int?
Ответ: Если выводить мапу в цикле порядок вывода будет рандомный. Если выводить через fmt.Print то порядок вывода будет по ключу

### 8. В чем разница make и new
Ответ: new - только аллоцирует память в куче, make - инициализирует объект

### 9. Сколько существует способов задать переменную типа slice или map?
Ответ: 3
```go
  slice  := []int{1, 2, 3} // 1
  slice1 := make([]int, 5, 10) // 2, make(type, len, cap)

  slice2 := new([]int) // 3
  *slice2 = append(*slice2, 1)
```

### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (a = 1
        p = &a)
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
Ответ: 1, 1. В функцию update передается копия p. Соответственно update изменит только копию

### 11. Что выведет данная программа и почему?
```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
Ответ: числа от 0 до 4 в рандомном порядке и после дедлок. wg нужно передать по ссылке
```go
// Исправление
...
go func(wg *sync.WaitGroup, i int) {
  fmt.Println(i)
  wg.Done()
}(&wg, i)
...
```

### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
Ответ: 0. Поскольку мы создаем новую переменную n в теле условия и инкрементируем уже его
```go
// Исправление
func main() {
    n := 0
    if true {
        n = 1
        n++
    }
    fmt.Println(n)
}
```

### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Ответ: [100, 2, 3, 4, 5]. В функцию someAction передается копия слайса в котором тот же указатель на массив. Поэтому мы можем перезаписать нулевой индекс. Append в свою очередь реаллоцирует память и поскольку слайс был передан копией, 6 не запишется в оригинальный слайс

### 14. Что выведет данная программа и почему?
```go
func main() {
    slice := []string{"a", "a"}

    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```
Ответ: [b b a][a a]; В анонимной функции мы реалоцируем слайс и записываем в конец "a". Затем изменяем этот реаллоцированный слайс (не оригинальный) и выводим в stdout. После анонимной функции мы выводим неизмененный оригинальный слайс
